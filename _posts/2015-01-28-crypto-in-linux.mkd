---
layout: post
title:  "Authentification par clé, utilisation"
date:   2015-01-28 17:05:31
categories: linux crypto

---



Introduction
------------

Le principe de clé publique / privée est l'une des solutions la plus adaptée
pour sécuriser les échanges électroniques. Qu'il s'agisse de crypter / décrypter
des messages, signer des documents, certifier l'identité d'un service ou d'un
utilisateur, le recours aux principes de clés est largement répendu. Voyons un
peu sur quoi repose ce principe et comment il est utilisé.

> Les commandes utilisées ici font partis des outils standards du monde Linux.
> Si vous utilisez une autre plateforme (Mac OSX), il se peut que les versions
> des outils ou leurs options diffèrent, voir que ces outils ne soient tout
> simplement pas disponible pour votre plateforme.


Principes
---------

On ne peut pas parler de sécurité par clé privée / publique sans parler de
ce qui est à sa base : La cryptographie asymetrique et ses principaux
algorithmes qui sont :

- **RSA** :  
  Développé par 3 mathématiciens en 1977 puis breveté en 1983 par le
  MIT (USA). Cet algorithme est l'un des plus utilisés aujourd'hui. Le nom RSA
  vient de ses trois créateurs : Ron **R**ivest, Adi **S**hamir and Leonard
  **A**dleman

- **DSA** :  
  Développé par le NIST en 1991 pour disposer d'un algorithme non breveté
  (et contrer par la même RSA) afin de completer l'arsenal de sécurité proposé
  par les spécifications DSS (Digital Signature Standard).

- **ECC** :  
  Abbréviation de Elliptic Curve Cryptography, cet algorithme est initialement
  proposé par deux mathématiciens en 1985 mais est réellement utilisé depuis
  2004 pour sa capacité a être plus efficace que RSA pour une longueure de clé
  identique.


**Cryptographie asymétrique... Kesako ?**

Les algorithmes de cryptographie les plus courants sont dits *symétriques*,
c'est à dire qu'ils reposent sur un élément secret partagé par l'émetteur et
le destinataire du message (le mot de passe ou la passphrase). Le principal
inconvénient de ce système et que si l'élément secret est divulgé, la sécurité
n'est plus assurée.

A l'inverse, la cryptographie *asymetrique* implique d'utiliser deux éléments
adressés à chacune des deux parties : Ce sont les clés. Chaque algorithme
dispose d'un type de clé qui lui est propre (une clé RSA ne peut être utilisée
que par un algorithme RSA).

Points communs des algorithmes asymétriques :

1.  Tout repose sur un jeu de deux clés.
2.  La clé privée permet de déduire la clé publique (et une seule). Elle ne doit
    pas être divulgée.
3.  La clé publique ne permet pas de déduire la clé privée, elle peut être
    distribuée librement.
4.  On peut chiffrer un message avec la clé publique, mais il faudra la clé
    privée pour le déchiffrer. C'est également vrai dans l'autre sens.

> Le point faible de la sécurité par clé publique / privée reside dans la
> longueure de la clé utilisée (qui conditionne ne niveau de chiffrement) et
> surtout dans le fait que la clé privée doit absolument rester secrête.


Définitions
-----------

**Clé privée**  
C'est l'élement principal dans un jeu de clé privé/public. Quelque soit
l'algorithme associé à votre clé privée, on ne peut déduire qu'une - et une
seule - clé publique d'après une clé privée... Si vous rejouez plusieurs fois le
générateur de clé publique depuis une clé privé, vous aurez à chaque fois la
même clé publique en résultat.


**Clé publique**  
Elle est générée dans un deuxième temps (certains outils le font de façon
transparent) d'après la clé privée. Il n'est pas possible de déduire la clé
privée depuis une clé publique (elle est de taille plus petite).


**Passphrase**  
C'est comparable à un mot de passe, mais concerne plutôt une phrase plus ou
moins longue, et donc plus difficile à trouver pour d'éventuels pirateurs. En
général, une longueure moyenne de passphrase compte 10 à 30 caractères.


**Algorithme de Hashage**  
Méthode mathématique permettant de créer une forme d'empreinte d'après un
contenu. Toute modification de contenu fournira une empreinte différente.
L'action de "hasher" un fichier s'appel un encodage (notez que ce terme
s'applique également à d'autres actions).


**Algorithme de Cryptage**  
Méthode mathématique permettant de transformer un message clair en message
chiffré, et donc illisible. Le cryptage est reversible et permet toujours de
retrouver l'original non crypté, mais il faut en général utiliser un élément
secrêt (mot de passe ou passphrase). L'action de crypter un fichier s'appel
"cryptage" ou "chiffrement".


Usages
------

Dans quels cas nous utilisons les clés publiques / privées ?

**Le cryptage**  
  Son rôle est d'assurer qu'un échange entre deux personnes (ou deux machines)
  ne pourra pas être intercepté. On l'utilise via des protocoles SSL (internet),
  SSH et globalement les différents protocoles de sécurisation utilisés en
  télécommunication.

**La signature**  
  Un peu plus complexe à réaliser car il nécessite d'utiliser un autre
  algorithme, dit de *hashage* tels que SHA-1 ou MD5. Cet algorithme permet de
  générer une empreinte d'un message (et non un cryptage car on ne peut déduire
  le message d'origine d'après son empreinte). Toute modification du message
  aura pour conséquence de modifier l'empreinte.

  Le principe de signature repose sur la génération d'une empreinte sur 2
  éléments : Le message que l'on souhaite signer et la clé publique du
  signataire. Parfois, on a également un certificat, mais ce n'est pas
  nécessaire. Enfin, l'empreinte est chiffrée via la clé privée du signataire.

  Pour vérifier la signature, on déchiffre l'empreinte via la clé publique qui
  l'accompagne et on regénère une nouvelle empreinte (via le même algorithme de
  hashage). Si les deux empreintes correspondent, on a la preuve que :

  - Le message (ou document) original n'a pas été altéré
  - C'est bien le signataire qui a signé le document.
  - Dans le cas où un certificat est inclus, ce dernier est vérifié via la même
    procédure, répétée sur tout la chaîne de certification (jusqu'au certificat
    Root). Il est parfois nécessaire d'utiliser un certificat si on n'a pas
    recours à une architecture qui centralise les clés publiques et valide leur
    porteur (propriétaire).

  La signature est à la base de la création des certificats : Un document
  électronique normalisé (X.509) contenant des informations administratives et
  techniques (adresse du site que l'on souhaite certifier par exemple) qui est
  signé par une autorité de certification, un peut à l'image du couple
  tampon/signature produit par une organisation ou administration.

**Authentification**  
  L'un des protocoles d'authentification les plus répendus est le SSH (et oui,
  lorsque vous utilisez GitHub pour vos projets, vous échangez via SSH). Le
  principe est de déclarer sur le serveur la clé publique d'un utilisateur
  (généralement, le fichier ```.ssh/authorized_keys```).

  SSH utilise les deux types d'algorithmes : Asymétrique et symétrique. Lorsque
  un utilisateur se connecteur à un serveur via SSH et qu'il dispose d'une clé
  publique sur ce serveur, SSH va créer une passphrase. Celle-ci est transmise à
  l'utilisateur mais de façon cryptée (avec la clé publique).

  Le logiciel de l'utilisateur va décrypter la passphrase avec la clé privée.
  Ensuite, tous les échanges seront cryptés en utilisant comme élément secrêt la
  passphrase préalablement échangée.

  Cette méthode à pour interêt :

  - De valider que l'utilisateur a bien la clé privée. Dans le cas contraire, il
    ne serait pas en mesure de déchiffrer la passphrase pour entamer des
    échanges cryptés.
  - Le cryptage / décryptage par algorithme symétrique est plus rapide. On
    utilise donc le principe des clés que pour la phase d'authentification.

> **Pourquoi mon client SSH ajoute le serveur à sa liste ?**  
> Cette technique permet au serveur de s'assurer que l'utilisateur est bien qui
> il prétend être. Mais ce n'est pas vrai dans l'autre sens. C'est pourquoi une
> empreinte du serveur est générée par le logiciel SSH pour chaque nouvelle
> connexion. Si l'empreinte change, l'utilisateur est averti. La liste des
> serveurs et leur empreinte est dans le fichier ```.ssh/known_hosts```


Les formats de fichiers
-----------------------

C'est bien beau de parler de clé, mais ce n'est qu'une suite de caractères. Pour
les utiliser efficacement, il est nécessaire de les stocker dans un fichier qui
va servir de conteneur et éventuellement, encapsuler la ou les clés dans un
certificat. C'est là qu'on va parler de format de fichier et préciser ses usages
ci dessous (notez qu'il en existe bien plus).


### DER (Distinguished Encoding Rules)

Conteneur binaire issu de la  spécification [X.690][X.690] définissant l'un des
formats supporté par la norme d'encodage ANS.1 ; En dehors de l'embarqué, on
lui préfère le format PEM.

Utilisé pour :

- Stocker une clé : .der
- Stocker un certificat au format X.509 (standard): .crt, .cer, .cert

Pour convertir une clé privée stockée dans un fichier PEM vers un format DER,
utilisez la commande suivante (clé au format RSA) :

```
openssl rsa -inform PEM -outform DER -in id_rsa.pem -out id_rsa.der
```


### PEM (Privacy Enhanced Email)

Conteneur ASCII (texte) utilisant un jeu de caractère réduit ([base64][RFC-3548])
supporté par tous les systèmes informatiques. Il est issus du protocole de
sécurisation d'email du même nom ([RFC-1421][RFC-1421], suivit par la
[RFC-1424][RFC-1424]). Un fichier PEM contient un ou plusieurs éléments pour
lesquels il est auto-descriptif : Il indique le type de contenu (certificat,
clé publique / privée), son format (clé RSA, DSA, ECC) et l'algorithme de
cryptage si utilisé (DES3, AES).
> Bien qu'il soit possible de stocker dans un fichier PEM plusieurs éléments, il
> est recommandé de se limiter à un élément par fichier.

Utilisé pour :

- Stocker une clé publique ou privée (avec ou sans cryptage) : .key .pem
- Stocker un certificat au format X.509 (standard): .crt, .cer, .cert
- Stocker une demande de certificat : .csr
- Stocker une liste de révocation de certificats : .crl

Pour convertir une clé privée stockée dans un fichier DER vers un format PEM,
utilisez la commande suivante (clé au format RSA) :

```
openssl rsa -inform DER -outform PEM -in id_rsa.der -out id_rsa.pem
```

### PKCS 7

Conteneur en standard ouvert ([RFC-2315][RFC-2315]) ne pouvant pas inclure de clé privé.
Utilisé pour stocker un certificat serveur avec sa chaîne de certification, ce
format est reconnu en natif par le framework Java et MS Windows.  
**Extentions** : .p7b .p7c


### PKCS 12

Conteneur issu d'un standard privé pouvant inclure une / des clé(s)
privé(s) et disposant de mécanismes de sécurité supplémentaires par rapport
au format PEM. Utilisé pour stocker un certificat serveur avec sa chaîne de
certification, il est depuis le format recommandé sur plateforme Windows (par
rapport à PKCS#7). Un conteneur PKCS 12 peut être converti en PEM.  
**Extentions** : .pfx .pkcs12 .p12

Pour convertir un contenu PKCS#12 en format PEM :

- Récupérer la clé privée :  
  ```
  openssl pkcs12 -nocerts -in cert.p12 -out mykey.pem
  ```

- Récupérer le certificat :  
  ```
  openssl pkcs12 -clcerts -nokeys -in cert.p12 -out mycert.crt
  ```

### Les autres formats

**Open-SSH** : Ce format de stockage est dès plus rudimentaires. Il est
utilisé par Open SSH et ne permet pas de crypter son contenu. Les outils Open
SSH utilisent automatiquement le format PEM dès qu'il faut crypter la clé.
L'alogithme de cryptage de la clé est AES, mais il est possible d'en utiliser
d'autres via les outils OpenSSL (dont l'exellent DES3).

Noter qu'il existe bien d'autres formats, dont ceux utilisés pour GnuPG / GPG et
qui leur sont spécifiques, ainsi que toutes les variantes des formats pré-cités.



Générer des clés RSA
--------------------

> Pour les besoins de l'exemple, et parce que RSA est largement répendu, je
> fournis des exemples que pour ce type de clé.


### Avec OpenSSH

Le moyen le plus rapide et le plus simple pour générer sa clé privée et en
déduire la clé publique à la volé est d'utiliser le commande OpenSSH suivante :

```
ssh-keygen -t rsa -b 2048
```

La clé publique est dans le fichier ```id_rsa.pub``` dans un format propre à
OpenSSH et la clé privé est dans ```id_rsa``` (sans extention) dont le format
est le même, sauf si vous avez donné une passphrase pour crypter la clé. Dans ce
cas, la clé privée est stockée au format PEM et cryptée via l'algorithme AES en
128 bits.

> Attention : Putty (Windows) requiert une clé stockée au format PEM et cryptée
> en DES3.

Il n'est pas nécessaire de conserver la clé publique. Celle-ci pourra être
déduite d'après la clé privée via la commande suivante :

```
ssh-keygen -f id_rsa -y > id_rsa.pub
```

**RESULTAT**

```
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCvYwy4ZcnP3j74D8f06WVWHGPxIK8pIs8qDOE6loQR
SRauPf8Vy0TbT3TBovysWUa1I5b6EFdLfO29HkbebhqsIAVh2wgYf4tWte2zMWGvujGS0P7Dzx2wBrcn
xVEFYRfFsT2PhI+NaoGmyDYeR+1tMDL4oPL7uSzzOPwHZih83eYMuRElIZDD3b697IVDxHLGp8uJSJAE
0VAlx7Uujd3UUjUt/Jc4ngsORGOR6ikW4u70tbWtzbTWQ7ldysJHSATLbivg2jH2P5VnuHy2LWEuAjnW
BvTtzpIB/EQFM1GufPQiUU//8CAP112CUbdLcd3G6ifvmVKXBAN6IOMY/+g9
```


### Avec OpenSSL

Utilisez openssl pour contrôler plus facilement la génération de vos clés et
sotcker vos clés dans des fichiers PEM génériques, c'est à dire sans les
extentions descriptives que OpenSSH ajoute. Ce format est correctement supporté
par tous les logiciels exploitant des clés ainsi que OpenSSH.

Ici, nous générons les mêmes clés (RSA), mais avec l'algorithme de cryptage DES3
pour la clé privé. Les clés sont stockées dans un fichier PEM au format PKCS#8.

```
openssl genpkey -des3 -out id_rsa -outform PEM -algorithm RSA -pkeyopt
rsa_keygen_bits:2048
```

Algorithme associé à la clé : RSA ou DSA  
Format de sortie : PEM ou DEM  
Cryptage de la clé privée : des3 ou aes-128-cbc  

**RESULTAT**

```
-----BEGIN ENCRYPTED PRIVATE KEY-----
MIIFDjBABgkqhkiG9w0BBQ0wMzAbBgkqhkiG9w0BBQwwDgQIL6yMBt4gNfkCAggA
MBQGCCqGSIb3DQMHBAiTUclx1mMrOwSCBMgaz8FWgjlA0rVHaicaHj3xpLfriipQ
BEeBKEneOrpJmAsmJ5qXE5Nayyn0NDH61JWTC7Wwn55quVJ0uMSwKLRt6PknFoAz
2u/NhQo9+t6vjzUa0xajDqwIr2rt10/xCpQkzhEJiwVs8m44zSoIKqv+EB+kdFAa
vOeeEc/lw5BbYnu64/bb74cr8D8Y0fzR3pvkAPBYTKXdtdyzsUsCqtNl41PWuQff
54LeWlCxygMd24bvM9DO4QVX/Ixw5Y736TJkPT0g4va4pTftsGbUGD87JBsZKcG+
l3XFudhrdnPzqKdzfMRMJZAULNafO5YHngWmXDmhDYSgqeEd3Kqk/laepgkgcf+r
rrhJGHmOsuX/zEkAGoq3UG8TUz2ochaLPo/6iRhEKELIxLN5lI1wx++UcOsLzNY6
Vs+NlXjzFYUY8vUmODXD6OBrXGzPJqFV8deBH3ww/jXAcSfxBfdckP5Oc821XJhW
0zvFu0foaUOQgcb4Mm4sp0SpkQnDrmGWNZP6edsg6g9+V3Bio0UvjTn7vNFh2ZOi
w3+3/hZpJi44CWMk9QR79aOKQiIo1SprjkvPHRNwI5qYs+BXaRE73CNAjdblntTy
lWiG/cHcDnPuZ9XsSyEE8FpkR6ZnZj54aG09pGXfEBrXIOSjv0s2CJw2hh02fCF3
c9SmKffPeiKrXqpwdv+fWZQJ+rPceKu3QWswdgQQ5xf3ElTFDYbxyz27PnGSEHgt
lLIOKBssfN1TK00Nt+L58PhH8pWNibQqKrO496Df7ZiGu8aD3or/CRR8FlTXHrHs
zVCKLmOkNXKgZBApErpScrRCswCGfyScIQVl5ASJq9MT3LizQJbHTwKLrRXiKoB+
jHg0cR/30vQ+MT5Y83yayAJveaV5GH9Gh70UvmAqjlaN9geCqHdUomvLt8DtLaqb
cbpTlyKKN5ITwOBK6gpZp69frxn3h7zn6xxSQneM4NBdc4NtvkttbsYgLzbXDP6k
1QOz8JmFDkT0kZ9HGmE2mVxx4ExI2uPPVNyYD9yvKBDy2cpEKYYAthuYkDlSFvlC
NBXz+3OmSGOKkPAPkL/U+mcd/y5FXGhHb+LMKW9+mZXNaQ1cDtDskhdKO1TTJUgZ
+vkNrrmcTWngmlqRxPKA0duhU+OD5D32SfnzBt+XLvyM6w2a8gl+lIWh3A+QCuIx
SmHf3E/A384Tzz3Q68fuJnqNVuBt2KKL2BYwif8zGCjZhh33I7VtdTr7a2QluKK8
SrXVXlIBcogwr64t1v2g4ul4Kd7zNxFHWYli9Z6UgEob6i0wibmnUkDsTvsc/u9w
x/BukROq1Qv/nsVcUWUp93hBLhgjXCt3r8GBK7dN/+bwqpcUCS/48G6o+K42YC5V
P/dmskSdnBXjGeq/wiGLPEiJ0apSq2HZQQxy4UJlD3h1Y0UWhDndCp4Rpu2U5DtU
uTZ4lwylVFAib1xdUZ7SOybT4GAXnmDccp3cObLWpeuKNxXgYG1vvqEBWCMrfhT2
/950u9adwGRITu+FZq+viXFveOzvEl6S9RBHzYUCQpyq91jJB7zWzZYjwp3UXScq
YGQwLceTGyOZ9G7WRyru/u2WqJazPEYwXx3lge0j3/BBxkFZgrqZf61sJ3n53cvh
aAs=
-----END ENCRYPTED PRIVATE KEY-----
```

Beaucoup sont habitués à l'ancienne syntaxe mais elle avait l'inconvénient
d'avoir un jeu d'option trop spécifique entre les différents algorithmes de clé.
Cependent, OpenSSL la supporte toujours très bien :

```
openssl genrsa -des3 -out id_rsa 2048
```

**RESULTAT**

```
-----BEGIN RSA PRIVATE KEY-----
Proc-Type: 4,ENCRYPTED
DEK-Info: DES-EDE3-CBC,788EEB11AA55046D

H4Ya4Df5yEyG9KJJ+gvkXCzsKWgKgRq/SSlu9CjlYped1MUXlwAMVBXB467hTap5
yvmrxg4xsOZOSRlEXuInKBz/B+j/PMHx1jZ0/UwPz/eMIGDK5uVgRyx06gMZfIJy
/MUKVY/vUNoy0uKYMFWBElHxJaLNIfFJ+reaQDfmkQRMekG7BRSBfh31jfU37d0r
+Ny38B0yvebIupgQqpQiTUStq7vB0No0mjPxj1M3sZT/AEOPQ1XJWiH6VOGbhga+
NqQDhShRI3IR/aTr+Q6P04qfNrk6bPM5zzG+9F0YkVoBcuo6/YGoJ6WDIlNCzU/Z
+6qY1pckYgIbE7kS0okvnR8YQeWoXrf3DbLf/LEFwouitOKV06zd2dZ+jCD77nJh
L5TcxEEnKg0TRUHNawSdEbBI8qkG5kUx/BdZT4vB3jEIcFj4KB2Ck1gnPSHFRA59
Tp/lx+n5poq2qKr9Bg7y/HLnyn3FTZOpHchrtug1f5aMIRrlsaYULVuy8kLoz7i4
+6CQmetaCD1ghWDFh9Sk96u4rvYaea43MtWsRghV6H2TEwLmBy3Ggio1GENurNGx
oRlIuyDwB3vOhnfVpV4vv2znqrZ2vWe+qvoGV2Vd7Dj27j6JLOnXMH2K1lCW/vcK
JhbBK6FfFy7UUP8Kjs1gwayBaYBu2F7X76uey0AiqvkYFAK8j52ataDcsJ5EgjUA
OdwHiId8o29AQc140SYaH60fHPtxegIpLMPjk+1xvntEuuwu6zDMtIib4PD5SCy7
5Aek1iOy43N0lGOeP0uULev1tmQlw4JmnLY+SkmnPdjVIG4A3XhX/fiOvyr/NLIB
Rro9D/XLZZMaGPNhzATWmYeqNDuFaQHRx2WtcrXM/u8NQ57YJSMUmKtHoBxGN8Um
NLfDcPHuvUl4tX8TiOVXitAKWuFkJ3GU95OvJLeGPjjF+rthdWEwAZrsMrglwBNM
Hr8gRn4hZ5KPIEZBBEoeXc9PeJkHCb230FDIupvQcPh5cd2Kbm2lIUndFXdWCsZa
93MP0vIz+8TeKvOEts09cW3lzueR4nijoclolXYLwLLEVA1YcYsR/RmwLDGP5gzc
g6UyCyd8Jj+UiUzo7C3Ia9qmXGWlfjx0bP5OE/Y8Da00I+z3TnSxDNoXCetHqEky
dOoVlM9/V0N7DSQR7WpRZKdQ7NXk/yBmOe5WULdoqoDCNxjiOZmk1W/QyhUOKErN
pNnmiCFgvc31gUv8uC8ajZoUHB06NZ9Ryb4HLzpxSZm0ke9a7PD5iEf7gZJk3Aj5
YCG51QqtcOboaUdRUtWQh9ykWuUsMaJmFDvC9y7H4eOF9b4ZJHK1BZXxb9iH52Tw
u8q6EbVSxqumVXMu/t/r7NOYUNDEjW8bKkbKcMmaFM2wtCIuKXkWhmAUfulH8+ne
ku9Xe8aEFDkY/R6kZlxKhTKOXSTayGeeSqi3fWaNWXHyLGXXqTwMfdCN0B4rNjGl
dsECokxH/Xar9v03/1QuYiY+vSPDMHPd94vfGCtqyhO5zO45SDHdUkztymGyJrcG
UYWNW+XSSKQAeABfx1HiNwgtU4DJ3Si1f8EIOB7PY7bG5lZ7VZhgvA==
-----END RSA PRIVATE KEY-----
```

> ```genrsa``` génère un fichier PEM avec les extentions descriptives usuelles
> de OpenSSH. Ces exentions descriptives sont facultatives et non exploitées par
> les applications.

Pour déduire la clé publique correspondante (format PEM) :

```
openssl rsa -in id_rsa -pubout > id_rsa_pub.pem
```

**RESULTAT**

```
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAr2MMuGXJz94++A/H9Oll
Vhxj8SCvKSLPKgzhOpaEEUkWrj3/FctE2090waL8rFlGtSOW+hBXS3ztvR5G3m4a
rCAFYdsIGH+LVrXtszFhr7oxktD+w88dsAa3J8VRBWEXxbE9j4SPjWqBpsg2Hkft
bTAy+KDy+7ks8zj8B2YofN3mDLkRJSGQw92+veyFQ8RyxqfLiUiQBNFQJce1Lo3d
1FI1LfyXOJ4LDkRjkeopFuLu9LW1rc201kO5XcrCR0gEy24r4Nox9j+VZ7h8ti1h
LgI51gb07c6SAfxEBTNRrnz0IlFP//AgD9ddglG3S3Hdxuon75lSlwQDeiDjGP/o
PQIDAQAB
-----END PUBLIC KEY-----
```

### Clé publique au format PEM (PKCS8) ou OpenSSH ?

Si vous souhaitez échanger avec un administrateur système votre clé publique, il
faudra favoriser le format OpenSSH car la clé y est stocké en clair sans
encodage base64 au contraire de PEM. Une clé stocké au format OpenSSH permet
facilement son rajout dans la liste des clés autorisées : ```authorized_keys```.

Cependant, pour des échanges de clés publiques sur des services en ligne,
préférez les fichiers PEM au format PKCS#8, largement reconnu. Si vous envoyez
une clé sous ce format à un administrateur, il lui faudra la convertir en clé
OpenSSH via la commande suivante, ce qui est peut pratique pour lui :

```ssh-keygen -t rsa -f id_rsa_pub.pem -i -m PKCS8```

Cette commande converti une clé RSA au format PEM (PKCS8) vers le format
OpenSSH. Ce qui donne le résultat suivant :

```
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCvYwy4ZcnP3j74D8f06WVWHGPxIK8pIs8qDOE6loQR
SRauPf8Vy0TbT3TBovysWUa1I5b6EFdLfO29HkbebhqsIAVh2wgYf4tWte2zMWGvujGS0P7Dzx2wBrcn
xVEFYRfFsT2PhI+NaoGmyDYeR+1tMDL4oPL7uSzzOPwHZih83eYMuRElIZDD3b697IVDxHLGp8uJSJAE
0VAlx7Uujd3UUjUt/Jc4ngsORGOR6ikW4u70tbWtzbTWQ7ldysJHSATLbivg2jH2P5VnuHy2LWEuAjnW
BvTtzpIB/EQFM1GufPQiUU//8CAP112CUbdLcd3G6ifvmVKXBAN6IOMY/+g9
```

### Extraire la clé publique d'un certificat

Si vous avez un certificat et souhaitez en extraire sa clé publique :  
(remplacer ```-inform def``` par ```-inform pem``` si vous avez un fichier au
format PEM)

```
openssl x509 -inform der -in certificat_file.cer -noout -pubkey > server_key.pub
```


Utiliser dans SSH
-----------------


Utiliser sur GitHub
-------------------

Signer sous Git
---------------

Utilisation dans des certificats
--------------------------------

Pour aller plus loin
--------------------




---


Clé privée et publique
----------------------

Les techniques de cryptographie basés sur des algorithme dits "asymétriques" and
that I
sont à la base des méthodes de signature, de cryptage et d'authentification
par clé privée / publique. La technique de vérification, signature et cryptage
repose sur le principe qu'il n'est pas possible de décrypter un message sans
posséder l'autre partie de la clé et vice versa. A partir de ce principe, est
définit une clé privée qui restera secrète. A partir de cette clé, sera
généré une clé publique transmise à un tier ayant pour but d'authentifier
le porteur de la clé privée ou d'échanger de façon crypté avec lui.

A une clé privée ne peut être généré qu'une clé publique. En revanche, à une
clé publique peut correspondre un nombre virtuellement infini de clé. C'est
pourquoi il n'est pas possible de déduire la clé privée depuis la clé publique,
mais l'inverse n'est pas vrai.

Il existe 3 algorithmes utilisés pour ces techniques de cryptographie qui sont
RSA, DSA et EEC et permettent de générées des clés qui leur sont propre.
Le niveau de garantie du cryptage dépend de la longueure de la clé.
Il est considéré qu'à minimat, il faut des clés de 2048 bits. Pour une
protection optimale, il est préférable d'opter pour des clés de 4096 bits.


Les conteneurs
--------------

Il en existe de différents types, parfois spécialisés pour un type de contenu
(comme les conteneurs PKS). Pour le stockage des clés, on utilise les formats
suivants :


### DER (Distinguished Encoding Rules)

Conteneur binaire issu de la  spécification [X.690][X.690] définissant l'un des
formats supporté par la norme d'encodage ANS.1 ; En dehors de l'embarqué, on
lui préfère le format PEM.

### PEM (Privacy Enhanced Email)

Conteneur ASCII (texte) utilisant un jeu de caractère réduit ([base64][RFC-3548])
supporté par tous les systèmes informatiques. Il est issus du protocole de
sécurisation d'email du même nom ([RFC-1421][RFC-1421], suivit par la
[RFC-1424][RFC-1424]). Un fichier PEM contient un ou plusieurs éléments pour
lesquels il est auto-descriptif : Il indique le type de contenu (certificat,
clé publique / privée), son format (clé RSA, DSA, EEC) et l'algorithme de
cryptage si utilisé (DES3, AES).
> Bien qu'il soit possible de stocker dans un fichier PEM plusieurs éléments, il
  est recommandé de se limiter à un élément par fichier.

Utilisé pour :

- Stocker une clé privée (avec ou sans cryptage) : .key .pem
- Stocker un certificat au format X.509 (standard): .crt, .cer, .cert
- Stocker une demande de certificat : .csr
- Stocker une liste de révocation de certificats : .crl



Clé SSH
-------

SSH utilise un jeu de clé de type RSA ou DSA (depuis SSH2). Les clients SSH
reconnaissent les formats de fichier Open-SSH, PEM et DER.

L'outil fournis avec SSH (ssh-keygen) stocke par défaut les clés dans un fichier
au format Open-SSH (suivant la norme [RFC-4716][RFC-4716]), ce format n'assurant
pas de cryptage. Dans le cas contraire, il utilise le format PEM et l'algorithme
de cryptage AES.

Si vous avez besoin d'utiliser un autre algorithme de cryptage (DES3 par
exemple, qui est plus robuste que AES), il faudra passer par OpenSSL.

> Le cryptage est recommandé pour proteger la clé privée. Une clé publique n'est
  jamais cryptée.

### Génération de clé

- Générer un jeu de clé RSA :  
  ```
  ssh-keygen -t rsa -b 2048 -C "username@server"
  ```  
  Si vous souhaitez forcer l'utilisation du format PEM pour stocker la clé
  privée, soit vous saisissez une passphrase, soit vous l'imposez via l'option
  ```-m PEM```

- Générer une clé privée crypté via l'algorithme DES3 : Comme indiqué plus haut,
  il vous faudra utiliser OpenSSL.  

- Générer une clé publique d'après la clé privée :


### Conversion de clé

- Convertir sa clé privée Open-SSH vers le format PEM :

- Convertir sa clé privée PEM vers le format Open-SSH :

- Convertir sa clé publique Open-SSh vers le format PEM :

- Convertir sa clé publique PEM vers le format Open-SSH :


### Actions usuelles

- Ajouter une clé publique à la liste des clés autorisées :

- Configurer son client SSH pour utiliser une clé privée :

- Ajouter sa clé privée à un client SSH Putty (Windows) :


### Utiliser SSH-Agent


Git
---

### Signer un tag

### Ajouter sa clé à un depôt Git (hors GitHub)

### Ajouter sa clé à un depôt GitHub


Certificats
-----------

Le certificat électronique est un document normalisé X.509 qui a été encodé et
parfois lui-même signé suivant la procédure décrite dans la RFC-5280. Les
certificats sont contenu dans un conteneur tels que PEM, PKCS12; PKCS7.

Ils sont utilisés pour fournir des informations (nom du site, adresse e-mail,
propriétaire) qui sont certifiées par une autorité de certificat (CA -
Certificate Authority). Ces informations permettent d'attester de la validité
de celui qui les possède et s'assurer qu'on s'adresse à la bonne machine ou
à la bonne personne.

Les certificats utilisent une technique de signature en s'appuyant sur une
architecture à clé publique/privée utilisant des techniques de cryptographie
asymétrique. S'il est courant de déduire une clé publique depuis la clé privée,
l'inverse donnerait trop de possibilités et rendrait le décryptage
virtuellement impossible.


### PKCS 7

Conteneur en standard ouvert ([RFC-2315][RFC-2315]) ne pouvant pas inclure de clé privé.
Utilisé pour stocker un certificat serveur avec sa chaîne de certification, ce
format est reconnu en natif par le framework Java et MS Windows.  
**Extentions** : .p7b .p7c


### PKCS 12

Conteneur issu d'un standard privé pouvant inclure une / des clé(s)
privé(s) et disposant de mécanismes de sécurité supplémentaires par rapport
au format PEM. Utilisé pour stocker un certificat serveur avec sa chaîne de
certification, il est depuis le format recommandé sur plateforme Windows (par
rapport à PKCS#7). Un conteneur PKCS 12 peut être converti en PEM.  
**Extentions** : .pfx .pkcs12 .p12


Pour convertir un contenu PKCS#12 en PEM (sous Linux) :

- Récupérer la clé privée :  
  ```
  openssl pkcs12 -nocerts -in cert.p12 -out mykey.pem
  ```

- Récupérer le certificat :  
  ```
  openssl pkcs12 -clcerts -nokeys -in cert.p12 -out mycert.crt
  ```


### CSR (Certificate Signing Request)

Fichier PEM contenant une demande de certificat généralement au format
PKCS10 ([RFC-2986][RFC-1986]) à transmettre auprès d'une autorité de certification
(communément abrégé en CA pour Certificate Authority). Celle-ci génère et signe
numériquement le nouveau certificat.  
**Extentions** : .csr .pkcs10 .p10

Un fichier CSR contient les informations suivantes :

- Nom de domaine complet (Full Qualified Domain Name).
- Organisation
- Division demandant le certificat (ou service)
- Ville / localité
- Pays / région
- Pays au code ISO (deux caractères, exemple : FR)
- E-mail
- Clé publique


#### Commandes (Linux)

> Sous Linux, utilisez openssl pour gérer tout ce qui est certificat
  (génération, demande de certificat, décodage et conversion)

- Générer un fichier CSR :  
  ```
  openssl req -new -keyout server.key -out server.csr
  ```

- Même chose mais en générant une nouvelle clé privée :  
  (Veillez à conserver la clé en lieu sûre et ne jamais la transmettre)  
  ```
  openssl req -new -newkey rsa:2048 -nodes -keyout myserver.key -out server.csr
  ```

**Fichier généré :**
<pre>
-----BEGIN CERTIFICATE REQUEST-----
MIICzTCCAbUCAQAwgYcxCzAJBgNVBAYTAkZSMQ8wDQYDVQQIDAZGcmFuY2UxDjAM
BgNVBAcMBVBhcmlzMQ0wCwYDVQQKDARBRjgzMRAwDgYDVQQLDAdERVZCTE9HMRUw
EwYDVQQDDAx3d3cuYWY4My5jb20xHzAdBgkqhkiG9w0BCQEWEGNvbnRhY3RAYWY4
My5jb20wggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDoz0vcsexbvnYU
nq8E22K5/7RJ8DuFnbPtE++xsCONENoa3J4/2BhjWoooGHlbrk+44JsM1EF7WW6k
Abm2+35bqZIWrqAKo065G9Jikwp/2diAnGB/Ng9YyOV2ocG2hnJdZJ8vdhsou9jX
MAJfxyWAt82NXEbgF49Ls3FEuFX25HD64YPu2jfcbscXf9xP5hZ5EElxri1iMQ1W
BF8AcIgIjF5xb9lDk3vuP7X0+q8Su9BYhJfjah3WGyBB4ZCyRyKRFJYYGqHmSAG3
SmC+3x3MUyd0IWIBFOO+M/8HK01WjlADFQD/ht7LcAhUVzqh+GuaA48rRzH6Dt1m
MbJ9ikgxAgMBAAGgADANBgkqhkiG9w0BAQsFAAOCAQEAcLPZgPjjJMePlduO3CG/
YPqAecMXyj4rw4LAiwijj0fogiAqNUONJcJDoydkbSXRMN0vcgsPb8OIvgmUz1ba
pZwkF9Wn0ISDlGHvx2c74obr+Bt41LIbszVPHXlem5V8F5CdqRhZSxlbwqvbG1EP
cL5DEuSuGUKqfl1basyYlgK0mqCp3HdBtTCO9xR1IYs70HKdKxnUiNtVzLgfiNYJ
jpRm9EobF1edWZnmmdz0xdYjQFajOyiAAznMK6Lf8IK0lBQ4y885jbe9dVxaELeG
idBChXMho0PlGYUw2gbLKrhAaFok2UQo8qzqS2LRx0AVQEnPeYl3/VmqKTsQRor9
VA==
-----END CERTIFICATE REQUEST-----
</pre>

- Décoder le fichier ci-dessus :  
  ```
  openssl req -in server.csr -noout -text
  ```


### CRL (Certificate Revocation List)

Fichier PEM ou DER contenant une liste de certificat à révoquer selon la
[RFC-3280][RFC-3280].  
**Extentions** : .crl




[RFC-2986]:       https://tools.ietf.org/rfc/rfc2986.txt
[RFC-3548]:       https://www.ietf.org/rfc/rfc3548.txt
[RFC-2315]:       https://tools.ietf.org/rfc/rfc2315.txt
[RFC-1421]:       https://tools.ietf.org/rfc/rfc1421.txt
[RFC-1424]:       https://tools.ietf.org/rfc/rfc1424.txt
[X.690]:          http://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf
[RFC-1986]:       https://tools.ietf.org/rfc/rfc2986.txt
[RFC-3280]:       http://www.ietf.org/rfc/rfc3280.txt
[RFC-4716]:       https://tools.ietf.org/rfc/rfc4716.txt
[RFC-5208]:       http://tools.ietf.org/rfc/rfc5208.txt

See also:
http://serverfault.com/questions/9708/what-is-a-pem-file-and-how-does-it-differ-from-other-openssl-generated-key-file
https://myonlineusb.wordpress.com/2011/06/19/what-are-the-differences-between-pem-der-p7bpkcs7-pfxpkcs12-certificates/

Autre :
http://www.networking4all.com/fr/support/certificats+ssl/manuels/apache/serveur+apache+http/g%C3%A9n%C3%A9rer+un+csr/
http://fr.wikipedia.org/wiki/X.509
http://en.wikipedia.org/wiki/Public-key_cryptography
http://www.cryptographyworld.com/algo.htm
http://en.wikipedia.org/wiki/PKCS_12
http://fr.wikipedia.org/wiki/X.509
http://en.wikipedia.org/wiki/PEM

https://support.ssl.com/Knowledgebase/Article/View/19/0/der-vs-crt-vs-cer-vs-pem-certificates-and-how-to-convert-them
https://help.ubuntu.com/community/SSH/OpenSSH/Keys
http://en.wikipedia.org/wiki/Ssh-keygen
http://help.globalscape.com/help/eft6/Server_SSH_Key_Formats.htm
http://stackoverflow.com/questions/12749858/rsa-public-key-format
http://askubuntu.com/questions/46424/adding-ssh-keys-to-authorized-keys
https://help.ubuntu.com/community/SSH/OpenSSH/Keys

A lire et relire :
https://www.netmeister.org/blog/ssh2pkcs8.html
